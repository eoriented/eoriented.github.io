<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ddia on Smart Tiger&#39;s blog</title>
    <link>https://eoriented.github.io/subcategories/ddia/</link>
    <description>Recent content in ddia on Smart Tiger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>eoriented@gmail.com (eoriented)</managingEditor>
    <webMaster>eoriented@gmail.com (eoriented)</webMaster>
    <lastBuildDate>Sat, 14 Nov 2020 21:04:28 +0900</lastBuildDate>
    
	<atom:link href="https://eoriented.github.io/subcategories/ddia/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>파티셔닝(Partitioning) - 2</title>
      <link>https://eoriented.github.io/post/partitioning-2/</link>
      <pubDate>Sat, 14 Nov 2020 21:04:28 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/partitioning-2/</guid>
      <description>이전 포스트에 이어서 파티셔닝에서 사용하는 리밸런싱 기법에 관해 살펴보고, 클라이언트에서 질의 요청을 어떻게 처리할 것인지에 관해 알아보겠습니다.
파티션 리밸런싱 리밸런싱이란 클러스터에서 한 노드가 담당하던 부하를 다른 노드를 옮기는 과정입니다. 이러한 리밸런싱이 필요한 경우는 시간이 지나면서 데이터베이스에 변화가 생기기 때문입니다.</description>
    </item>
    
    <item>
      <title>파티셔닝(Partitioning) - 1</title>
      <link>https://eoriented.github.io/post/partitioning-1/</link>
      <pubDate>Sat, 14 Nov 2020 12:05:31 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/partitioning-1/</guid>
      <description>데이터셋이 매우 크거나 질의 처리량이 매우 높은 경우 데이터를 파티션으로 쪼개야 합니다. 이번 포스트에서 이야기하는 파티셔닝은 대용량 데이터베이스에서 데이터를 작은 단위로 쪼개는 방법을 말합니다. 몽고DB, 엘라스틱서치, 솔라에서는 샤드라고 하며 HBase에서는 리전, 빅테이블에서는 태블릿(tablet), 카산드라와 리악에서는 vnode, 카우치베이스에서 vBucker이라고 부릅니다.</description>
    </item>
    
    <item>
      <title>배치 프로세싱(Batch processing) - 2</title>
      <link>https://eoriented.github.io/post/batch-procession-2/</link>
      <pubDate>Fri, 02 Oct 2020 22:28:51 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/batch-procession-2/</guid>
      <description>조인 여러 데이터셋에서 한 레코드가 다른 레코드와 연관되어 있는 것은 일반적입니다. 관계형 모델에서는 외래키, 문서 모델에서는 문서 참조, 그래프 모델에서는 간선이라고 부릅니다. 비정규화를 통해서 이러한 조인을 줄일 수는 있지만 완전한 제거는 어렵습니다. 배치 처리에서의 조인은 데이터셋 내의 모든 연관 관계를 다루는 것을 의미합니다.</description>
    </item>
    
    <item>
      <title>배치 프로세싱(Batch processing) - 1</title>
      <link>https://eoriented.github.io/post/batch-processing-1/</link>
      <pubDate>Mon, 20 Jul 2020 23:06:22 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/batch-processing-1/</guid>
      <description>배치 처리는 컴퓨터 연산의 오래된 형태 중에 하나입니다. 이미 배치 처리는 예전 부터 사용했습니다. 2004년에 발표된 구글의 맵리듀스는 과거 미국 인구 조사에서 천공 카드 집계기를 이용한 집계 처리와 유사합니다. 이와 같이 배치 처리는 입력 데이터로 집계 처리해서 결과를 보여줍니다.</description>
    </item>
    
    <item>
      <title>스트림 프로세싱(Stream Processing) - 2</title>
      <link>https://eoriented.github.io/post/stream-processing-2/</link>
      <pubDate>Sun, 19 Jul 2020 21:49:32 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/stream-processing-2/</guid>
      <description>데이터베이스와 스트림 메시지 브로커와 데이터베이스는 전혀 다른 범주의 도구로 바라볼 수 있지만 로그 기반 메시지 브로커는 데이터베이스에서 아이디어를 얻어 메시지 시스템에 적용하는데 성공하였습니다. 데이터베이스의 복제 로그(replication log)는 데이터베이스에 쓰는 이벤트 스트림으로 볼 수 있습니다.
변경 데이터 캡처(CDC, Change Data Capture) 변경 데이터 캡쳐는 데이터베이스에 기록하는 모든 데이터의 변경사항을 관찰해 다른 시스템으로 데이터를 복제할 수 있는 형태로 추출하는 과정을 말합니다.</description>
    </item>
    
    <item>
      <title>스트림 프로세싱(Stream Processing) - 1</title>
      <link>https://eoriented.github.io/post/stream-processing/</link>
      <pubDate>Sun, 05 Jul 2020 23:00:39 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/stream-processing/</guid>
      <description>일반적으로 배치 처리의 문제점은 입력의 변화가 특정 기간이 끝나야 반영이 되는 문제가 있습니다. 이러한 지연(Lag)을 줄이려면 더 자주 실행할 수 있도록 해야 합니다. 고정된 타임 슬라이스 별로 처리하는 것이 아닌 이벤트가 발생할 때마다 처리하도록 하는 것입니다.</description>
    </item>
    
    <item>
      <title>복제(Replication) - 2</title>
      <link>https://eoriented.github.io/post/replication-2/</link>
      <pubDate>Fri, 20 Dec 2019 22:19:26 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/replication-2/</guid>
      <description>동기식 복제와 비동기식 복제 이전 포스트에 이어서 복제에 관해 살펴보겠습니다. 복제는 동기 또는 비동기적으로 이루어집니다. 동기식 복제는 리더가 해당 팔로워가 쓰기를 수신했는지 확인해줄 때까지 기다리는 방식입니다. 아래의 그림에서는 Follwer1의 복제는 동기식으로 동작합니다.
 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 갖는 것을 보장합니다.</description>
    </item>
    
    <item>
      <title>복제(Replication) - 1</title>
      <link>https://eoriented.github.io/post/replication-1/</link>
      <pubDate>Mon, 18 Nov 2019 22:56:24 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/replication-1/</guid>
      <description>이번 장의 주제는 복제(Replication)입니다. 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 의미합니다. 복제를 통한 이점은 다양합니다. 첫째로, 지리적으로 사용자와 가까운 곳에 데이터가 존재할 수 있어서 지연 시간(latency)을 줄여줍니다. 둘째로, 시스템에 일부 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성(availability)를 높여줍니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 3</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-3/</link>
      <pubDate>Mon, 26 Aug 2019 22:56:19 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-3/</guid>
      <description>이전 포스트에 이어서 세 번째 포스트입니다. 이전 포스트에서는 SS테이블과 LSM 트리에 관해 알아보았습니다. 이번 포스트에서는 데이터베이스에서 가장 많이 사용하고 일반적인 색인 유형인 B 트리에 대해서 살펴보겠습니다.
B 트리 B 트리는 거의 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 사용할 뿐만 아니라 비관계형 데이터에서도 사용합니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 2</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-2/</link>
      <pubDate>Wed, 21 Aug 2019 22:56:25 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-2/</guid>
      <description>이전 포스트에 이어서 저장소와 검색을 계속 살펴보겠습니다. 이전 포스트 마지막 부분에 대한 설명은 해시 테이블을 통한 색인이 가진 제한사항에 대해 살펴보았습니다. 이러한 제한이 없는 색인 구조를 이어서 살펴보도록 하겠습니다.
SS 테이블과 LSM 트리   위 그림과 같이 log-structured 저장소 세그먼트는 key-value 쌍의 시퀀스입니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 1</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-1/</link>
      <pubDate>Sun, 18 Aug 2019 22:11:51 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-1/</guid>
      <description>이전 포스트에서는 데이터 모델과 질의 언어에 대해 알아보았습니다. 예를 들어 애플리케이션 개발자 관점에서 데이터베이스에 저장하는 데이터 포맷과 데이터를 다시 요청하는 메커니즘과 같은 것들을 살펴보았습니다. 이번 장에서는 데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해서 살펴볼 예정입니다.</description>
    </item>
    
    <item>
      <title>데이터 모델(Data Models)과 질의 언어(Query Languages) - 2</title>
      <link>https://eoriented.github.io/post/data-models-and-query-languages-2/</link>
      <pubDate>Wed, 31 Jul 2019 22:22:45 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/data-models-and-query-languages-2/</guid>
      <description>데이터를 위한 질의 언어 데이터베이스에 데이터를 질의하는 방법은 각각의 데이터 모델마다 조금씩 다릅니다. 일반적으로 알고 있는 관계형 모델의 경우는 SQL을 이용합니다. SQL은 선언형 질의 언어입니다. 그리고 선언형(declarative) 질의와 대조되는 질의 방식은 명령형(imperative) 질의 방식이 있습니다. 그러면 선언형과 명령형을 사용하여 데이터를 조회하는 방법을 한번 살펴보겠습니다.</description>
    </item>
    
    <item>
      <title>데이터 모델(Data Models)과 질의 언어(Query Languages) - 1</title>
      <link>https://eoriented.github.io/post/data-models-and-query-languages-1/</link>
      <pubDate>Wed, 31 Jul 2019 15:06:14 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/data-models-and-query-languages-1/</guid>
      <description>데이터 모델은 소프트웨어 개발에 있어서 가장 중요한 부분 중에 하나입니다. 다양한 종류의 데이터 모델에 대해 이해를 하고 있고, 애플리케이션 요구사항에 가장 적합한 모델을 찾아서 개발을 해야 합니다.
데이터 모델에 따라 어떤 종류의 사용법은 쉽고 어떤 동작은 지원하지 않습니다.</description>
    </item>
    
    <item>
      <title>신뢰성, 확장성, 유지보수성을 가진 애플리케이션</title>
      <link>https://eoriented.github.io/post/reliable-scalable-and-maintainable-applications/</link>
      <pubDate>Sun, 14 Jul 2019 18:31:01 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/reliable-scalable-and-maintainable-applications/</guid>
      <description>Compute-intensive(계산 중심) vs Data-intensive(데이터 중심) 과거에는 CPU 성능이 애플리케이션을 제한하는 요소였지만 오늘날에는 그렇지 않습니다. 최근에는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 애플리케이션을 제한하는 요소가 되었습니다. 이렇게 애플리케이션에서 사용하는 데이터의 특징에 맞춰서 설계를 해야 합니다. 그래서 이러한 애플리케이션을 Data-intensive application(데이터 중심 애플리케이션)이라고 합니다.</description>
    </item>
    
  </channel>
</rss>