<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on Smart Tiger&#39;s blog</title>
    <link>https://eoriented.github.io/subcategories/scala/</link>
    <description>Recent content in scala on Smart Tiger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>eoriented@gmail.com (eoriented)</managingEditor>
    <webMaster>eoriented@gmail.com (eoriented)</webMaster>
    <lastBuildDate>Thu, 14 May 2020 10:04:25 +0900</lastBuildDate>
    
	<atom:link href="https://eoriented.github.io/subcategories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Functor(펑터)와 Monad(모나드) - 2</title>
      <link>https://eoriented.github.io/post/functor-and-monad-2/</link>
      <pubDate>Thu, 14 May 2020 10:04:25 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/functor-and-monad-2/</guid>
      <description>이전 포스트에서는 펑터가 무엇인지에 관해 살펴보았습니다. 펑터는 유용한 추상화이지만 약간의 문제가 존재합니다. 펑터의 map 함수가 일반적인 값을 반환하는 경우에는 문제가 되지 않지만 만약 펑터를 반환하면 어떻게 될까요? 물론 펑터 역시 값이기 때문에 상관은 없겠지만 펑터를 반환하는 경우 결과가 조금 다르게 나올 수 있습니다.</description>
    </item>
    
    <item>
      <title>Functor(펑터)와 Monad(모나드) - 1</title>
      <link>https://eoriented.github.io/post/functor-and-monad-1/</link>
      <pubDate>Sun, 10 May 2020 13:18:56 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/functor-and-monad-1/</guid>
      <description>스칼라 언어를 주로 사용하고 있는 입장에서 펑터나 모나드와 같은 용어를 종종 접하게 됩니다. 그래서 이번 포스트에서는 펑터와 모나드가 무엇인지에 대해 살펴보겠습니다. 일반적으로 대부분의 프로그래머들은, 특히 함수형 언어로 개발을 하지 않는 개발자들은, 모나드란 단어를 보았을 때, 자신과는 무관한 컴퓨터 프로그래밍 개념이고 상관없는 것이라고 생각하고 그냥 지나칠 수 있습니다.</description>
    </item>
    
    <item>
      <title>스칼라 퓨처(Future)와 동시성(Concurrency) - 2</title>
      <link>https://eoriented.github.io/post/scala-future-and-concurrency-2/</link>
      <pubDate>Sat, 17 Aug 2019 11:11:46 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/scala-future-and-concurrency-2/</guid>
      <description>이전 포스트에 이어서 스칼라 Future의 다른 사용법에 대해 살펴보도록 하겠습니다.
4. Future 실패 처리하기 스칼라 Future는 실패한 퓨처를 다룰 수 있는 failed, fallBackTo, recover, recoverWith 메소드를 제공합니다.
4.1 failed Future[T]에서 실패한 Future를 예외를 저장한 Future[Throwable] 타입의 성공한 Future로 바꿔줍니다.</description>
    </item>
    
    <item>
      <title>스칼라 퓨처(Future)와 동시성(Concurrency) - 1</title>
      <link>https://eoriented.github.io/post/scala-future-and-concurrency-1/</link>
      <pubDate>Fri, 16 Aug 2019 23:04:42 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/scala-future-and-concurrency-1/</guid>
      <description>오늘 멀티 코어 프로세서가 대중화되면서 동시성에 대한 관심도 많이 늘어났습니다. 이러한 동시성 프로그래밍을 위해서 기존의 프로그래밍 언어들을 블로킹을 사용하여 동기화함으로써 동시성을 지원합니다. 자바의 경우도 마찬가지로 공유 메모리와 락을 기반으로 동시성을 지원하고 있습니다. 그러나 이러한 블로킹을 사용한 동기화의 경우 Deadlock이나 Starvation과 같은 문제가 발생할 수 있습니다.</description>
    </item>
    
  </channel>
</rss>