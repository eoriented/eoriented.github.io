<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Smart Tiger&#39;s blog</title>
    <link>https://eoriented.github.io/post/</link>
    <description>Recent content in Posts on Smart Tiger&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>eoriented@gmail.com (eoriented)</managingEditor>
    <webMaster>eoriented@gmail.com (eoriented)</webMaster>
    <lastBuildDate>Sat, 03 Apr 2021 22:12:02 +0900</lastBuildDate>
    
	<atom:link href="https://eoriented.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>로그 구조 스토리지(Log Structured Storage)</title>
      <link>https://eoriented.github.io/post/log-structured-storage/</link>
      <pubDate>Sat, 03 Apr 2021 22:12:02 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/log-structured-storage/</guid>
      <description>회계사는 기록을 수정해야 하면 이미 입력된 값을 지우지 않고 새로운 값을 다시 씁니다. 최종 결과를 구하려면 모든 항목을 재검토하고 합계액을 계산해야 합니다. 이러한 방식은 바로 오늘 포스트에서 살펴볼 로그 구조 스토리지(Log-Structured Storage)와 유사합니다.
또 다른 예로는 불변 스토리지(immutable storage)가 있습니다.</description>
    </item>
    
    <item>
      <title>데이터베이스 소개 및 훑어보기</title>
      <link>https://eoriented.github.io/post/database-overview/</link>
      <pubDate>Sat, 20 Mar 2021 18:13:58 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/database-overview/</guid>
      <description>데이터베이스 시스템의 선택은 중요합니다. 성능, 일관성 문제, 운영의 어려움과 같은 이유로 데이터베이스를 변경하게 되는 경우가 발생할 수 있습니다. 데이터베이스를 변경할 때 마이그레이션이 쉽지 않을 수도 있기 때문에 초기 설계 단계에서 애플리케이션의 특성에 알맞는 데이터베이스를 선택해야 합니다.</description>
    </item>
    
    <item>
      <title>스트리밍 두 번째 걸음 - 배치를 넘어서</title>
      <link>https://eoriented.github.io/post/streaming-102/</link>
      <pubDate>Fri, 01 Jan 2021 14:31:42 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/streaming-102/</guid>
      <description>이전 포스트에서는 데이터를 Bounded data와 Unbounded 데이터 구별하고, 그것을 처리하는 방법에 관해 살펴보았습니다. Unbounded data를 처리할 때 이벤트 시간과 처리 시간의 차이점에 대해서 다뤘습니다. 또한 윈도우 개념도 함께 알아보았습니다. 이번 포스트에서는 워터마크, 트리거, 어큐뮬레이션에 관해 자세히 살펴보겠습니다.</description>
    </item>
    
    <item>
      <title>스트리밍의 첫걸음 - 데이터 스트리밍 처리의 개념 정리</title>
      <link>https://eoriented.github.io/post/streaming-101/</link>
      <pubDate>Sat, 19 Dec 2020 15:06:33 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/streaming-101/</guid>
      <description>스트리밍 처리의 중요성이 점점 중요해지고 있습니다. Apache Spark Streaming부터 새로운 스트림 처리의 강자인 Apache Flink와 같은 스트리밍 처리 엔진 등의 사용 사례가 많아지고 있습니다. 그래서 이번 기회에 스트리밍 처리에 대한 기본 개념들에 대해 정리해보고자 합니다.</description>
    </item>
    
    <item>
      <title>[HBase] Scanner Caching vs Batching</title>
      <link>https://eoriented.github.io/post/hbase-caching-vs-batching/</link>
      <pubDate>Tue, 08 Dec 2020 22:35:38 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/hbase-caching-vs-batching/</guid>
      <description>HBase는 데이터베이스 시스템에서의 커서와 유사한 스캔 기능을 제공합니다. 스캔은 HBase에서 순차적이고 정렬된 저장 구조를 활용하는 방식입니다. 스캔을 사용하면 로우 키를 기반으로 하여 여러 데이터를 가져올 수 있습니다. 스캔은 로우 키가 정확히 일치하지 않아도 사용이 가능합니다.</description>
    </item>
    
    <item>
      <title>이벤트 시간 처리(Event Time Processing)와 워터마크(Watermark) - (feat. Apache Flink)</title>
      <link>https://eoriented.github.io/post/event-time-processing-and-watermark/</link>
      <pubDate>Sun, 29 Nov 2020 10:35:22 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/event-time-processing-and-watermark/</guid>
      <description>스트림 처리에서 바라보는 시간적 측면 중에 이벤트 시간(Event time) 기반으로 처리하는 방식에 대해 살펴보겠습니다. 최근에 데이터 처리 분야에서 스트리밍 애플리케이션 개발의 중요성이 더욱 커지고 있습니다. 만약 스트리밍 애플리케이션을 개발하게 되는 경우 애플리케이션의 목적에 따라 이벤트 시간(Event time)을 기준으로 처리할 것인지 처리 시간(Processing time) 기준으로 처리할 것인지 선택을 해야 할 것입니다.</description>
    </item>
    
    <item>
      <title>프로그래밍과 알고리즘 공부 방법 - 김창준님</title>
      <link>https://eoriented.github.io/post/how-to-study-programming-and-algorithm/</link>
      <pubDate>Sun, 22 Nov 2020 13:56:42 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/how-to-study-programming-and-algorithm/</guid>
      <description>우리 프로그래머들은 항상 공부해야 합니다. 우리는 지식을 중요하게 여깁니다. 하지만 지식에 대한 지식, 즉 내가 그 지식을 얻은 과정이나 방법 같은 것은 소홀히 여기기 쉽습니다. 따라서 지식의 축적과 공유는 있어도 방법론의 축적과 공유는 매우 드문 편입니다.</description>
    </item>
    
    <item>
      <title>HBase client API</title>
      <link>https://eoriented.github.io/post/hbase-client-api-basics/</link>
      <pubDate>Sun, 22 Nov 2020 09:31:21 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/hbase-client-api-basics/</guid>
      <description>HBase에 접근하기 위한 주요 인터페이스는 org.apache.hadoop.hbase.client의 HTable 클래스입니다. HTable 클래스를 통해서 HBase에 데이터를 저장하고 삭제하는 등 사용자 작업에 필요한 기능을 제공합니다. HBase에서 데이터를 변경하는 로우 단위의 모든 작업은 원자성(Atomic)이 보장됩니다. 원자성이 보장된다는 말은 무슨 의미일까요? 하나의 로우에 읽기나 쓰기 작업이 수행되는 동일 다른 클라이언트나 스레드에서 동일한 로우에 읽기나 쓰기를 시도해도 아무런 문제가 발생하지 않는다는 의미입니다.</description>
    </item>
    
    <item>
      <title>NoSQL 데이터베이스 선정 기준</title>
      <link>https://eoriented.github.io/post/nosql-dimensions/</link>
      <pubDate>Wed, 18 Nov 2020 10:12:53 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/nosql-dimensions/</guid>
      <description>이번 포스트에서는 애플리케이션을 개발할 때 관계형 데이터베이스가 아닌 NoSQL 데이터베이스를 선택할 때 참고할 수 있는 기준들을 살펴보면 도움이 될 것입니다. RDBMS와 NoSQL 데이터베이스의 대표적인 차이점은 스키마와 트랜잭션 속성이나 실제로 데이터를 저장하는 구조에서 살펴볼 수 있습니다. 애플리케이션을 개발할 때 애플리케이션이 가진 특징을 명확히 이해하고 있으면 다양한 데이터베이스 중에 알맞는 데이터베이스를 선택할 수 있을 것입니다.</description>
    </item>
    
    <item>
      <title>파티셔닝(Partitioning) - 2</title>
      <link>https://eoriented.github.io/post/partitioning-2/</link>
      <pubDate>Sat, 14 Nov 2020 21:04:28 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/partitioning-2/</guid>
      <description>이전 포스트에 이어서 파티셔닝에서 사용하는 리밸런싱 기법에 관해 살펴보고, 클라이언트에서 질의 요청을 어떻게 처리할 것인지에 관해 알아보겠습니다.
파티션 리밸런싱 리밸런싱이란 클러스터에서 한 노드가 담당하던 부하를 다른 노드를 옮기는 과정입니다. 이러한 리밸런싱이 필요한 경우는 시간이 지나면서 데이터베이스에 변화가 생기기 때문입니다.</description>
    </item>
    
    <item>
      <title>파티셔닝(Partitioning) - 1</title>
      <link>https://eoriented.github.io/post/partitioning-1/</link>
      <pubDate>Sat, 14 Nov 2020 12:05:31 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/partitioning-1/</guid>
      <description>데이터셋이 매우 크거나 질의 처리량이 매우 높은 경우 데이터를 파티션으로 쪼개야 합니다. 이번 포스트에서 이야기하는 파티셔닝은 대용량 데이터베이스에서 데이터를 작은 단위로 쪼개는 방법을 말합니다. 몽고DB, 엘라스틱서치, 솔라에서는 샤드라고 하며 HBase에서는 리전, 빅테이블에서는 태블릿(tablet), 카산드라와 리악에서는 vnode, 카우치베이스에서 vBucker이라고 부릅니다.</description>
    </item>
    
    <item>
      <title>배치 프로세싱(Batch processing) - 2</title>
      <link>https://eoriented.github.io/post/batch-procession-2/</link>
      <pubDate>Fri, 02 Oct 2020 22:28:51 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/batch-procession-2/</guid>
      <description>조인 여러 데이터셋에서 한 레코드가 다른 레코드와 연관되어 있는 것은 일반적입니다. 관계형 모델에서는 외래키, 문서 모델에서는 문서 참조, 그래프 모델에서는 간선이라고 부릅니다. 비정규화를 통해서 이러한 조인을 줄일 수는 있지만 완전한 제거는 어렵습니다. 배치 처리에서의 조인은 데이터셋 내의 모든 연관 관계를 다루는 것을 의미합니다.</description>
    </item>
    
    <item>
      <title>배치 프로세싱(Batch processing) - 1</title>
      <link>https://eoriented.github.io/post/batch-processing-1/</link>
      <pubDate>Mon, 20 Jul 2020 23:06:22 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/batch-processing-1/</guid>
      <description>배치 처리는 컴퓨터 연산의 오래된 형태 중에 하나입니다. 이미 배치 처리는 예전 부터 사용했습니다. 2004년에 발표된 구글의 맵리듀스는 과거 미국 인구 조사에서 천공 카드 집계기를 이용한 집계 처리와 유사합니다. 이와 같이 배치 처리는 입력 데이터로 집계 처리해서 결과를 보여줍니다.</description>
    </item>
    
    <item>
      <title>스트림 프로세싱(Stream Processing) - 2</title>
      <link>https://eoriented.github.io/post/stream-processing-2/</link>
      <pubDate>Sun, 19 Jul 2020 21:49:32 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/stream-processing-2/</guid>
      <description>데이터베이스와 스트림 메시지 브로커와 데이터베이스는 전혀 다른 범주의 도구로 바라볼 수 있지만 로그 기반 메시지 브로커는 데이터베이스에서 아이디어를 얻어 메시지 시스템에 적용하는데 성공하였습니다. 데이터베이스의 복제 로그(replication log)는 데이터베이스에 쓰는 이벤트 스트림으로 볼 수 있습니다.
변경 데이터 캡처(CDC, Change Data Capture) 변경 데이터 캡쳐는 데이터베이스에 기록하는 모든 데이터의 변경사항을 관찰해 다른 시스템으로 데이터를 복제할 수 있는 형태로 추출하는 과정을 말합니다.</description>
    </item>
    
    <item>
      <title>스트림 프로세싱(Stream Processing) - 1</title>
      <link>https://eoriented.github.io/post/stream-processing/</link>
      <pubDate>Sun, 05 Jul 2020 23:00:39 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/stream-processing/</guid>
      <description>일반적으로 배치 처리의 문제점은 입력의 변화가 특정 기간이 끝나야 반영이 되는 문제가 있습니다. 이러한 지연(Lag)을 줄이려면 더 자주 실행할 수 있도록 해야 합니다. 고정된 타임 슬라이스 별로 처리하는 것이 아닌 이벤트가 발생할 때마다 처리하도록 하는 것입니다.</description>
    </item>
    
    <item>
      <title>Functor(펑터)와 Monad(모나드) - 2</title>
      <link>https://eoriented.github.io/post/functor-and-monad-2/</link>
      <pubDate>Thu, 14 May 2020 10:04:25 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/functor-and-monad-2/</guid>
      <description>이전 포스트에서는 펑터가 무엇인지에 관해 살펴보았습니다. 펑터는 유용한 추상화이지만 약간의 문제가 존재합니다. 펑터의 map 함수가 일반적인 값을 반환하는 경우에는 문제가 되지 않지만 만약 펑터를 반환하면 어떻게 될까요? 물론 펑터 역시 값이기 때문에 상관은 없겠지만 펑터를 반환하는 경우 결과가 조금 다르게 나올 수 있습니다.</description>
    </item>
    
    <item>
      <title>Functor(펑터)와 Monad(모나드) - 1</title>
      <link>https://eoriented.github.io/post/functor-and-monad-1/</link>
      <pubDate>Sun, 10 May 2020 13:18:56 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/functor-and-monad-1/</guid>
      <description>스칼라 언어를 주로 사용하고 있는 입장에서 펑터나 모나드와 같은 용어를 종종 접하게 됩니다. 그래서 이번 포스트에서는 펑터와 모나드가 무엇인지에 대해 살펴보겠습니다. 일반적으로 대부분의 프로그래머들은, 특히 함수형 언어로 개발을 하지 않는 개발자들은, 모나드란 단어를 보았을 때, 자신과는 무관한 컴퓨터 프로그래밍 개념이고 상관없는 것이라고 생각하고 그냥 지나칠 수 있습니다.</description>
    </item>
    
    <item>
      <title>HBase 데이터 모델</title>
      <link>https://eoriented.github.io/post/hbase-data-model/</link>
      <pubDate>Mon, 06 Apr 2020 23:01:48 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/hbase-data-model/</guid>
      <description>이번 포스트에서는 HBase의 데이터 모델에 대해 살펴볼 예정입니다.
먼저 데이터 모델이란 무엇일까요? 데이터 모델이란 데이터를 인식하고 조작하는데 사용되는 모델을 말합니다.
데이터베이스를 사용하는 사람에게 데이터 모델은 데이터베이스 내의 데이터와 상호작용하는 방법을 이야기하는 것입니다.
HBase에서 데이터 모델을 어떻게 표현하는지 살펴보기 전에 HBase에서 사용하는 용어를 먼저 살펴보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>Spark에서 groupByKey 대신 reduceByKey 사용하기</title>
      <link>https://eoriented.github.io/post/avoid-groupbykey/</link>
      <pubDate>Sat, 14 Mar 2020 22:15:26 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/avoid-groupbykey/</guid>
      <description>이번 포스트에서는 스파크에서 빈번히 사용되는 transformation인 reduceByKey와 groupByKey의 동작에 대해 살펴보겠습니다. 먼저 스파크에서 reduceByKey와 groupByKey를 사용하여 단어 세기 예제를 작성해보도록 하겠습니다.
val words = Array(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;, &amp;#34;three&amp;#34;, &amp;#34;three&amp;#34;) val wordPairsRDD = sc.parallelize(words).map(word =&amp;gt; (word, 1)) val wordCountsWithReduce = wordPairsRDD .</description>
    </item>
    
    <item>
      <title>Introduction to Kafka</title>
      <link>https://eoriented.github.io/post/introduction-to-kafka/</link>
      <pubDate>Thu, 12 Mar 2020 21:07:27 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/introduction-to-kafka/</guid>
      <description>1. Apache Kafka 아파치 카프카(이하 카프카)는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템입니다.
  카프카는 여러 시스템과 장치를 연결하는 중요한 역할을 수행합니다. 카프카는 높은 처리량과 실시간 처리를 할 수 있습니다. 이러한 카프카는 다음의 4가지 특징을 가지고 있습니다.</description>
    </item>
    
    <item>
      <title>Docker and Container</title>
      <link>https://eoriented.github.io/post/docker-and-container/</link>
      <pubDate>Sun, 16 Feb 2020 15:21:35 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/docker-and-container/</guid>
      <description>Container 먼저 컨테이너란 무엇일까요? 컨테이너는 Docker의 정식 홈페이지에서 다음과 같이 정의하고 있습니다.
 Package Software into Standardized Units for Development, Shipment and Deployment
 컨테이너는 애플리케이션에게 격리된 실행 환경을 제공해주는 가상화 기술입니다. 컨테이너 단위로 OS, Library, Application을 패키징 할 수 있습니다.</description>
    </item>
    
    <item>
      <title>복제(Replication) - 2</title>
      <link>https://eoriented.github.io/post/replication-2/</link>
      <pubDate>Fri, 20 Dec 2019 22:19:26 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/replication-2/</guid>
      <description>동기식 복제와 비동기식 복제 이전 포스트에 이어서 복제에 관해 살펴보겠습니다. 복제는 동기 또는 비동기적으로 이루어집니다. 동기식 복제는 리더가 해당 팔로워가 쓰기를 수신했는지 확인해줄 때까지 기다리는 방식입니다. 아래의 그림에서는 Follwer1의 복제는 동기식으로 동작합니다.
 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 갖는 것을 보장합니다.</description>
    </item>
    
    <item>
      <title>복제(Replication) - 1</title>
      <link>https://eoriented.github.io/post/replication-1/</link>
      <pubDate>Mon, 18 Nov 2019 22:56:24 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/replication-1/</guid>
      <description>이번 장의 주제는 복제(Replication)입니다. 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 의미합니다. 복제를 통한 이점은 다양합니다. 첫째로, 지리적으로 사용자와 가까운 곳에 데이터가 존재할 수 있어서 지연 시간(latency)을 줄여줍니다. 둘째로, 시스템에 일부 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성(availability)를 높여줍니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 3</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-3/</link>
      <pubDate>Mon, 26 Aug 2019 22:56:19 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-3/</guid>
      <description>이전 포스트에 이어서 세 번째 포스트입니다. 이전 포스트에서는 SS테이블과 LSM 트리에 관해 알아보았습니다. 이번 포스트에서는 데이터베이스에서 가장 많이 사용하고 일반적인 색인 유형인 B 트리에 대해서 살펴보겠습니다.
B 트리 B 트리는 거의 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 사용할 뿐만 아니라 비관계형 데이터에서도 사용합니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 2</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-2/</link>
      <pubDate>Wed, 21 Aug 2019 22:56:25 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-2/</guid>
      <description>이전 포스트에 이어서 저장소와 검색을 계속 살펴보겠습니다. 이전 포스트 마지막 부분에 대한 설명은 해시 테이블을 통한 색인이 가진 제한사항에 대해 살펴보았습니다. 이러한 제한이 없는 색인 구조를 이어서 살펴보도록 하겠습니다.
SS 테이블과 LSM 트리   위 그림과 같이 log-structured 저장소 세그먼트는 key-value 쌍의 시퀀스입니다.</description>
    </item>
    
    <item>
      <title>저장소(Storage)와 검색(Retrieval) - 1</title>
      <link>https://eoriented.github.io/post/storage-and-retrieval-1/</link>
      <pubDate>Sun, 18 Aug 2019 22:11:51 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/storage-and-retrieval-1/</guid>
      <description>이전 포스트에서는 데이터 모델과 질의 언어에 대해 알아보았습니다. 예를 들어 애플리케이션 개발자 관점에서 데이터베이스에 저장하는 데이터 포맷과 데이터를 다시 요청하는 메커니즘과 같은 것들을 살펴보았습니다. 이번 장에서는 데이터베이스 관점에서 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법에 대해서 살펴볼 예정입니다.</description>
    </item>
    
    <item>
      <title>스칼라 퓨처(Future)와 동시성(Concurrency) - 2</title>
      <link>https://eoriented.github.io/post/scala-future-and-concurrency-2/</link>
      <pubDate>Sat, 17 Aug 2019 11:11:46 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/scala-future-and-concurrency-2/</guid>
      <description>이전 포스트에 이어서 스칼라 Future의 다른 사용법에 대해 살펴보도록 하겠습니다.
4. Future 실패 처리하기 스칼라 Future는 실패한 퓨처를 다룰 수 있는 failed, fallBackTo, recover, recoverWith 메소드를 제공합니다.
4.1 failed Future[T]에서 실패한 Future를 예외를 저장한 Future[Throwable] 타입의 성공한 Future로 바꿔줍니다.</description>
    </item>
    
    <item>
      <title>스칼라 퓨처(Future)와 동시성(Concurrency) - 1</title>
      <link>https://eoriented.github.io/post/scala-future-and-concurrency-1/</link>
      <pubDate>Fri, 16 Aug 2019 23:04:42 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/scala-future-and-concurrency-1/</guid>
      <description>오늘 멀티 코어 프로세서가 대중화되면서 동시성에 대한 관심도 많이 늘어났습니다. 이러한 동시성 프로그래밍을 위해서 기존의 프로그래밍 언어들을 블로킹을 사용하여 동기화함으로써 동시성을 지원합니다. 자바의 경우도 마찬가지로 공유 메모리와 락을 기반으로 동시성을 지원하고 있습니다. 그러나 이러한 블로킹을 사용한 동기화의 경우 Deadlock이나 Starvation과 같은 문제가 발생할 수 있습니다.</description>
    </item>
    
    <item>
      <title>데이터 모델(Data Models)과 질의 언어(Query Languages) - 2</title>
      <link>https://eoriented.github.io/post/data-models-and-query-languages-2/</link>
      <pubDate>Wed, 31 Jul 2019 22:22:45 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/data-models-and-query-languages-2/</guid>
      <description>데이터를 위한 질의 언어 데이터베이스에 데이터를 질의하는 방법은 각각의 데이터 모델마다 조금씩 다릅니다. 일반적으로 알고 있는 관계형 모델의 경우는 SQL을 이용합니다. SQL은 선언형 질의 언어입니다. 그리고 선언형(declarative) 질의와 대조되는 질의 방식은 명령형(imperative) 질의 방식이 있습니다. 그러면 선언형과 명령형을 사용하여 데이터를 조회하는 방법을 한번 살펴보겠습니다.</description>
    </item>
    
    <item>
      <title>데이터 모델(Data Models)과 질의 언어(Query Languages) - 1</title>
      <link>https://eoriented.github.io/post/data-models-and-query-languages-1/</link>
      <pubDate>Wed, 31 Jul 2019 15:06:14 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/data-models-and-query-languages-1/</guid>
      <description>데이터 모델은 소프트웨어 개발에 있어서 가장 중요한 부분 중에 하나입니다. 다양한 종류의 데이터 모델에 대해 이해를 하고 있고, 애플리케이션 요구사항에 가장 적합한 모델을 찾아서 개발을 해야 합니다.
데이터 모델에 따라 어떤 종류의 사용법은 쉽고 어떤 동작은 지원하지 않습니다.</description>
    </item>
    
    <item>
      <title>Git 명령어 요약 정리 (Cheat sheet)</title>
      <link>https://eoriented.github.io/post/git-cheat-sheet/</link>
      <pubDate>Sat, 27 Jul 2019 17:06:56 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/git-cheat-sheet/</guid>
      <description>git은 오늘날 가장 많이 사용하는 버전 관리 시스템 중 하나입니다. 오늘은 git의 자주 사용하는 명령어에 대해서 살펴보고자 합니다. 먼저 각 명령어에 따른 흐름이 어떻게 변하는지 다음 그림을 통해 알 수 있습니다.
  생성하기   새로운 로컬 저장소를 생성하기</description>
    </item>
    
    <item>
      <title>신뢰성, 확장성, 유지보수성을 가진 애플리케이션</title>
      <link>https://eoriented.github.io/post/reliable-scalable-and-maintainable-applications/</link>
      <pubDate>Sun, 14 Jul 2019 18:31:01 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/reliable-scalable-and-maintainable-applications/</guid>
      <description>Compute-intensive(계산 중심) vs Data-intensive(데이터 중심) 과거에는 CPU 성능이 애플리케이션을 제한하는 요소였지만 오늘날에는 그렇지 않습니다. 최근에는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 애플리케이션을 제한하는 요소가 되었습니다. 이렇게 애플리케이션에서 사용하는 데이터의 특징에 맞춰서 설계를 해야 합니다. 그래서 이러한 애플리케이션을 Data-intensive application(데이터 중심 애플리케이션)이라고 합니다.</description>
    </item>
    
    <item>
      <title>딥러닝(Deep Learning) 살펴보기 2탄</title>
      <link>https://eoriented.github.io/post/deep-learning-overview-2/</link>
      <pubDate>Sat, 07 Oct 2017 15:00:00 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/deep-learning-overview-2/</guid>
      <description>지난 포스트에 Deep learning 살펴보기 1탄을 통해 딥러닝의 개요와 뉴럴 네트워크, 그리고 Underfitting의 문제점과 해결방법에 관해 알아보았습니다. 그럼 오늘은 이어서 Deep learning에서 학습이 느린 문제점을 어떠한 방식으로 해결하고 연구하고 있는지 한번 알아보도록 하겠습니다.
Neural Network 복습 기존의 뉴럴 네트워크는 weight parameter들을 최적화(optimize)를 하기 위하여 Gradient Descent 방법을 사용했습니다.</description>
    </item>
    
    <item>
      <title>딥러닝(Deep Learning) 살펴보기 1탄</title>
      <link>https://eoriented.github.io/post/deep-learning-overview-1/</link>
      <pubDate>Sun, 01 Oct 2017 13:04:48 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/deep-learning-overview-1/</guid>
      <description>이번 포스트에서는 Deep learning에 대해 살펴볼 예정입니다. 이번 포스트는 Reference에 있는 내용을 정리한 것입니다. Deep learning은 대세가 되었습니다. 주변에서 딥러닝이라는 이야기가 많이 들립니다. 딥러닝이란 무엇인지 알아보도록 하겠습니다. 오늘날 딥러닝을 가능하게 해준 3가지가 있습니다.
 빅데이터  데이터가 많은게 깡패입니다.</description>
    </item>
    
    <item>
      <title>Oozie Workflow Pattern 3</title>
      <link>https://eoriented.github.io/post/oozie-workflow-pattern-3/</link>
      <pubDate>Sun, 01 Oct 2017 11:35:48 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/oozie-workflow-pattern-3/</guid>
      <description>이전 포스트에는 Oozie의 워크플로우 패턴중 하나인 fork-and-join 패턴에 관해서 알아보았습니다. 이번 시간에는 워크플로우 내에 액션의 결과에 조건을 주어 다음 액션을 어디로 수행할 것인지 결정할 수 있는 capture-and-decide 패턴에 대해 알아보도록 하겠습니다.
capture-and-decide pattern capture-and-decide 패턴이라고 하니까 약간 어려운 느낌이 있지만 실제로는 간단한 패턴이죠.</description>
    </item>
    
    <item>
      <title>Oozie Workflow Pattern - 2</title>
      <link>https://eoriented.github.io/post/oozie-workflow-pattern-2/</link>
      <pubDate>Sat, 30 Sep 2017 14:19:26 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/oozie-workflow-pattern-2/</guid>
      <description>이전 포스트에는 Oozie의 워크플로우 패턴중 하나인 Point-to-Point 패턴에 관해서 알아보았습니다. 이번 시간에는 fork-and-join 패턴에 대해 알아보도록 하겠습니다.
fork-and-join pattern fork-and-join 패턴은 Fan-out 패턴이라고도 합니다. 이와 같은 형태의 워크플로우는 여러 액션들이 나누어 실행한 후 해당 액션들이 다 정상적으로 완료된 후 다음 액션을 수행해야하는 경우 많이 사용합니다.</description>
    </item>
    
    <item>
      <title>Oozie Workflow Pattern - 1</title>
      <link>https://eoriented.github.io/post/oozie-workflow-pattern-1/</link>
      <pubDate>Sun, 24 Sep 2017 15:06:15 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/oozie-workflow-pattern-1/</guid>
      <description>Oozie가 무엇인지 궁금한 분들을 Apache Oozie 소개라는 이전 포스트를 참고하시기 바랍니다. 일반적으로 Oozie에서 많이 사용되는 워크플로우 패턴에 대해서 알아봅시다.
순차적 액션 수행 (Point-to-Point Pattern) 가장 간단한 형태로 수행하는 워크플로우 형태가 되겠습니다. 말그대로 순차적으로 액션을 수행할 때 사용합니다.</description>
    </item>
    
    <item>
      <title>Apache Oozie 소개</title>
      <link>https://eoriented.github.io/post/introduction-to-oozie/</link>
      <pubDate>Sat, 23 Sep 2017 23:15:56 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/introduction-to-oozie/</guid>
      <description>Oozie 개요 Oozie는 정식 홈페이지에 나와 있듯이 Hadoop ecosystem에서 사용하는 Workflow Scheduler(혹은 orchestration) 프레임워크입니다. Oozie에서 제공하는 기능은 크게 아래의 3가지와 같습니다.
 Scheduling  특정 시간에 액션 수행 주기적인 간격 이후에 액션 수행 이벤트가 발생하면 액션 수행   Coordinating  이전 액션이 성공적으로 끝나면 다음 액션 시작   Managing  액션이 성공하거나 실패했을 때 이메일 발송 액션 수행시간이나 액션의 단계를 저장    Oozie 용어  Action  우지에서 실행할 수 있는 하나의 작업 단위 MapReduce 작업, Spark 작업, Shell script 등   Workflow  Action들의 제어와 의존 관계를 DAG(Directed acyclic graph) 표현   Coordinator  Data sets과 Workflow를 실행하는 스케줄을 정의   Bundle  코디네이터의 모임    Oozie Architecture  우지는 Client-Server Model의 형태입니다.</description>
    </item>
    
    <item>
      <title>의사 결정 트리(Decision Tree)</title>
      <link>https://eoriented.github.io/post/decision-tree/</link>
      <pubDate>Mon, 22 Jun 2015 16:59:44 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/decision-tree/</guid>
      <description>의사 결정 트리는 분류(Classification) 기술 중 가장 일반적으로 사용되는 방법입니다. 의사 결정 트리의 개념이 익숙하진 않겠지만 대표적으로 예를 들을 수 있는 것이 바로 스무고개라는 게임입니다. 스무고개는 총 20개의 질문만 허락되며, 그에 대한 답변으로 ‘예’ 혹은 ‘아니오’로만 대답하여서 추측하여 답에 도달하는 게임이죠.</description>
    </item>
    
    <item>
      <title>gcc로 컴파일하는 방법</title>
      <link>https://eoriented.github.io/post/how-to-compile-using-gcc/</link>
      <pubDate>Fri, 15 May 2009 10:36:10 +0900</pubDate>
      <author>eoriented@gmail.com (eoriented)</author>
      <guid>https://eoriented.github.io/post/how-to-compile-using-gcc/</guid>
      <description>1. gcc 동작 과정   gcc
원래는 GNU C Compiler를 의미 했지만 1999년부터 GNU Compiler Collection을 의미한다.
  gcc가 실행시키는 프로그램
         cpp 전처리기   cc1 컴파일러   as 어셈블러   ld 링커    1) 전처리 단계</description>
    </item>
    
  </channel>
</rss>